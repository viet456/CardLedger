// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

enum LegalityStatus {
    Legal
    Banned
}

enum CardCondition {
    tcgNearMint
    tcgLightlyPlayed
    tcgModeratelyPlayed
    tcgHeavilyPlayed
    tcgDamaged
}

model Set {
    id             String   @id
    name           String
    series         String
    tcgPlayerSetId String?  @unique
    printedTotal   Int
    total          Int
    ptcgoCode      String?
    releaseDate    DateTime
    updatedAt      DateTime
    cards          Card[]

    // Flattened legalities using the enum
    unlimited LegalityStatus?
    standard  LegalityStatus?
    expanded  LegalityStatus?

    // Images
    symbolImageKey String?
    logoImageKey   String?

    symbolOptimized Boolean @default(false)
    logoOptimized   Boolean @default(false)

    // Indexes for faster queries
    @@index([name])
    @@index([series])
    @@index([releaseDate])
}

enum Supertype {
    Pok√©mon
    Trainer
    Energy
}

model Card {
    id          String            @id
    name        String
    supertype   Supertype
    subtypes    SubtypesOnCards[]
    hp          Int?
    types       TypesOnCards[]
    evolvesFrom String?
    evolvesTo   String[]

    abilities            Ability[]
    attacks              Attack[]
    weaknesses           Weakness[]
    resistances          Resistance[]
    convertedRetreatCost Int?

    rules            String[]
    ancientTraitName String?
    ancientTraitText String?
    set              Set      @relation(fields: [setId], references: [id])
    setId            String

    rarity   Rarity? @relation(fields: [rarityId], references: [id])
    rarityId Int?
    artist   Artist? @relation(fields: [artistId], references: [id])
    artistId Int?

    number                 String
    nationalPokedexNumbers Int[]
    pokedexNumberSort      Int?
    releaseDate            DateTime

    // Card legalities
    standard  LegalityStatus?
    expanded  LegalityStatus?
    unlimited LegalityStatus?

    imageKey        String?
    imagesOptimized Boolean @default(false)

    marketStats   MarketStats? // Curret price
    priceHistory  PriceHistory[]
    inCollections CollectionEntry[]

    // -- Indexes for faster queries -- 
    // filtering only
    // For paginated sorting 
    // card within set
    // single set sorted by card number
    @@index([ancientTraitName])
    @@index([ancientTraitText])
    @@index([convertedRetreatCost, id])
    @@index([supertype, id])
    @@index([rarityId, id])
    @@index([artistId, id])
    @@index([name, setId])
    @@index([setId, number, id])
    @@index([name, id])
    @@index([pokedexNumberSort, id])
    @@index([releaseDate, id])
}

model MarketStats {
    id     Int    @id @default(autoincrement())
    card   Card   @relation(fields: [cardId], references: [id], onDelete: Cascade)
    cardId String @unique

    // TCGplayer prices
    tcgNearMintLatest         Decimal? @db.Decimal(10, 2)
    tcgLightlyPlayedLatest    Decimal? @db.Decimal(10, 2)
    tcgModeratelyPlayedLatest Decimal? @db.Decimal(10, 2)
    tcgHeavilyPlayedLatest    Decimal? @db.Decimal(10, 2)
    tcgDamagedLatest          Decimal? @db.Decimal(10, 2)

    // TCGplayer maket trends
    tcgNearMintTrend         String?
    tcgLightlyPlayedTrend    String?
    tcgModeratelyPlayedTrend String?
    tcgHeavilyPlayedTrend    String?
    tcgDamagedTrend          String?

    // TCGplayer listings count
    tcgNearMintListings         Int?
    tcgLightlyPlayedListings    Int?
    tcgModeratelyPlayedListings Int?
    tcgHeavilyPlayedListings    Int?
    tcgDamagedListings          Int?

    tcgPlayerUpdatedAt DateTime?
}

model PriceHistory {
    id        String   @id @default(cuid())
    timestamp DateTime @default(now())

    // TCGplayer prices
    tcgNearMint         Decimal? @db.Decimal(10, 2)
    tcgLightlyPlayed    Decimal? @db.Decimal(10, 2)
    tcgModeratelyPlayed Decimal? @db.Decimal(10, 2)
    tcgHeavilyPlayed    Decimal? @db.Decimal(10, 2)
    tcgDamaged          Decimal? @db.Decimal(10, 2)

    tcgNearMintVolume         Int?
    tcgLightlyPlayedVolume    Int?
    tcgModeratelyPlayedVolume Int?
    tcgHeavilyPlayedVolume    Int?
    tcgDamagedVolume          Int?

    cardId String
    card   Card   @relation(fields: [cardId], references: [id], onDelete: Cascade)

    @@unique([cardId, timestamp])
    @@index([cardId, timestamp])
}

model Subtype {
    id    Int               @id @default(autoincrement())
    name  String            @unique
    cards SubtypesOnCards[]
}

model SubtypesOnCards {
    cardId    String
    card      Card    @relation(fields: [cardId], references: [id])
    subtype   Subtype @relation(fields: [subtypeId], references: [id])
    subtypeId Int

    @@id([cardId, subtypeId])
    @@index([subtypeId])
}

model Type {
    id   Int    @id @default(autoincrement())
    name String @unique

    cards       TypesOnCards[]
    weaknesses  Weakness[]
    resistances Resistance[]
    attackCosts AttackCost[]
}

model TypesOnCards {
    id     Int    @id @default(autoincrement())
    cardId String
    card   Card   @relation(fields: [cardId], references: [id])
    type   Type   @relation(fields: [typeId], references: [id])
    typeId Int

    @@unique([cardId, typeId])
    @@index([typeId])
}

model Ability {
    id     Int    @id @default(autoincrement())
    name   String
    text   String
    type   String
    card   Card   @relation(fields: [cardId], references: [id])
    cardId String
}

model Attack {
    id                  Int          @id @default(autoincrement())
    card                Card         @relation(fields: [cardId], references: [id])
    cardId              String
    name                String
    cost                AttackCost[]
    convertedEnergyCost Int
    damage              String?
    text                String?
}

model AttackCost {
    id       Int    @id @default(autoincrement())
    attack   Attack @relation(fields: [attackId], references: [id])
    attackId Int
    type     Type   @relation(fields: [typeId], references: [id])
    typeId   Int

    @@index([typeId])
}

model Weakness {
    id     Int     @id @default(autoincrement())
    card   Card    @relation(fields: [cardId], references: [id])
    cardId String
    type   Type    @relation(fields: [typeId], references: [id])
    typeId Int
    value  String?

    @@unique([cardId, typeId])
    @@index([typeId])
}

model Resistance {
    id     Int     @id @default(autoincrement())
    card   Card    @relation(fields: [cardId], references: [id])
    cardId String
    type   Type    @relation(fields: [typeId], references: [id])
    typeId Int
    value  String?

    @@unique([cardId, typeId])
    @@index([typeId])
}

model Rarity {
    id    Int    @id @default(autoincrement())
    name  String @unique
    cards Card[]
}

model Artist {
    id    Int    @id @default(autoincrement())
    name  String @unique
    cards Card[]
}

model User {
    id            String            @id
    name          String?
    email         String
    emailVerified Boolean           @default(false)
    image         String?
    createdAt     DateTime          @default(now())
    updatedAt     DateTime          @default(now()) @updatedAt
    sessions      Session[]
    accounts      Account[]
    collection    CollectionEntry[]

    username        String?
    displayUsername String?

    @@unique([email])
    @@unique([username])
    @@map("user")
}

model Session {
    id        String   @id
    expiresAt DateTime
    token     String
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    ipAddress String?
    userAgent String?
    userId    String
    user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([token])
    @@map("session")
}

model Account {
    id                    String    @id
    accountId             String
    providerId            String
    userId                String
    user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
    accessToken           String?
    refreshToken          String?
    idToken               String?
    accessTokenExpiresAt  DateTime?
    refreshTokenExpiresAt DateTime?
    scope                 String?
    password              String?
    createdAt             DateTime  @default(now())
    updatedAt             DateTime  @updatedAt

    @@map("account")
}

model Verification {
    id         String   @id
    identifier String
    value      String
    expiresAt  DateTime
    createdAt  DateTime @default(now())
    updatedAt  DateTime @default(now()) @updatedAt

    @@map("verification")
}

model CollectionEntry {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())

    userId String
    user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
    cardId String
    card   Card   @relation(fields: [cardId], references: [id], onDelete: Cascade)

    purchasePrice Float
    condition     CardCondition @default(tcgNearMint)

    // future card variant support, eg Holo, Foil
    variantName String?

    @@index([userId])
    @@index([cardId])
}
